#!/usr/bin/env python3
"""Aruco marker based localization.

Reads frames from the default camera, detects the marker IDs ``0-3`` placed
as a 2x2 grid spaced one meter apart and publishes the robot pose in 2D.
The calibration data generated by ``camera_calibration_node.py`` is used
for pose estimation.  A bias (``camera_offset``) can be supplied to account
for the transform between the camera and the robot base.
"""
import os
import yaml
import cv2
import cv2.aruco as aruco
import numpy as np
import rospy
import rospkg
from geometry_msgs.msg import Pose2D


class ArucoDetector:
    def __init__(self):
        rospy.init_node('aruco_detector')
        rp = rospkg.RosPack()
        pkg_path = rp.get_path('aruco_localization')

        info_file = os.path.join(pkg_path, 'config', 'camera_info.yaml')
        fs = cv2.FileStorage(info_file, cv2.FILE_STORAGE_READ)
        self.camera_matrix = fs.getNode('camera_matrix/data').mat()
        self.dist_coeffs = fs.getNode('distortion_coefficients/data').mat()
        fs.release()

        map_file = os.path.join(pkg_path, 'maps', 'map.yaml')
        with open(map_file) as f:
            self.map = yaml.safe_load(f)

        self.marker_length = rospy.get_param('~marker_length', 0.05)
        self.camera_offset = rospy.get_param('~camera_offset', [0.0, 0.0])
        self.cap = cv2.VideoCapture(0)
        self.dict = aruco.getPredefinedDictionary(aruco.DICT_4X4_100)
        self.pose_pub = rospy.Publisher('/robot_pose', Pose2D, queue_size=1)

    def compute_pose(self, ids, corners):
        poses = []
        for i, marker_id in enumerate(ids.flatten()):
            if marker_id not in range(4):
                continue
            rvec, tvec, _ = aruco.estimatePoseSingleMarkers(
                corners[i], self.marker_length, self.camera_matrix,
                self.dist_coeffs)
            tvec = tvec[0][0]
            world_pos = self.map[f'marker_{marker_id}']
            cam_x = world_pos[0] - tvec[0]
            cam_y = world_pos[1] - tvec[1]
            poses.append((cam_x, cam_y))
        if not poses:
            return None
        # average if multiple markers seen
        x = sum(p[0] for p in poses) / len(poses)
        y = sum(p[1] for p in poses) / len(poses)
        return x, y

    def spin(self):
        if not self.cap.isOpened():
            rospy.logerr('Camera not available')
            return
        rate = rospy.Rate(30)
        while not rospy.is_shutdown():
            ret, frame = self.cap.read()
            if not ret:
                rate.sleep()
                continue
            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            corners, ids, _ = aruco.detectMarkers(gray, self.dict)
            pose = None
            if ids is not None:
                pose = self.compute_pose(ids, corners)
                aruco.drawDetectedMarkers(frame, corners, ids)
            cv2.imshow('aruco_detection', frame)
            cv2.waitKey(1)

            if pose is not None:
                msg = Pose2D()
                msg.x = pose[0] + self.camera_offset[0]
                msg.y = pose[1] + self.camera_offset[1]
                msg.theta = 0.0
                self.pose_pub.publish(msg)
            rate.sleep()
        self.cap.release()
        cv2.destroyAllWindows()


if __name__ == '__main__':
    ArucoDetector().spin()
